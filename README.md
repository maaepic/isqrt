# Just a several temporary isqrt() tests

Немного кода isqrt с целью посмотреть как пара компиляторов его оптимизируют. И результаты.  
Требуются: gcc, clang, rust, perf.


### сорцы
* [`isqrt.c`](isqrt.c) - обычный C код.  
  `for (int i = 0; i < 100000000; i++) { 1.0f / sqrtf(x); }`
* [`isqrt.rs`](isqrt.rs) - обычный Rust код.  
  `for _ in 0..100000000 { 1.0 / x.sqrt(); }`
* [`fast-isqrt.c`](fast-isqrt.c) - quake реализация быстрого isqrt на C  
* [`sse-isqrt.c`](sse-isqrt.c) - SSE реализация isqrt на C  

fast-isqrt.c собирается только для x32, так как интересна только его древняя оптимизация для FPU, а x64 требует уже SSE.  прочем, sse версия тоже добавлена.
для x32 точно так же собрана и обычная версия на 1/sqrt().


### как запускать
```shell
$ make # чтобы собрались бинари
$ sudo ./test.sh # чтобы прогнать perf
```


### выхлоп
* *.asm - ассемблерные дампы интересующих бинарей (для ручной проверки что же там нагенерилось),
* perf.log - копия терминального лога perf для каждого файла


### результаты

* для всех компиляторов включен уровень оптимизации O3 (`-O3`, `opt-level=3`),
* все бинари показывают 100000000 (100М) бранчей, то есть все не выбросили и не оптимизировали циклы,
  * gcc, к слову, без `volatile int i` оптимизирует количество циклов до половинного (собирает математику из двух f32 в одну f64)
* все бинари не ложатся на бренч-мисах (ну еще бы), так что не замедляются на неверных предсказаниях одного и того же сто миллионов раз крутящего цикла (слегка сарказм),
* все цифры взяты после пары десятков прогонов, чтобы уж точно прогреть все cpu и кеши, и никаких тяжелых фотовых задач,
* все бинари показывают всего пару context-switches, cpu-migrations и не больше 80 page-faults, так что все ок.

##### быстрая сравнительная таблица, детальнее внизу.  
почему для сравнения взяты cycles? так нагляднее. если где-то подобный код использовать, что все вот эти "stalled-cycles-frontend" можно нивелировать другим кодом, который ээфективно загрузит все задействованные alu и никаких простоев не будет. так что просто смотрим сколько циклов потратил cpu (с учетом внутреннего реордеринга и распараллельивания команд, и т.д. и т.п.)  
то есть для грубой первой оценки этого вполне достаточно.

```
gcc:        261 512 241      cycles
clang:      269 941 192      cycles
sse gcc:    202 577 821      cycles
fast gcc:   601 396 220      cycles
just gcc: 1 638 050 827      cycles
rust:       842 574 350      cycles
```


#### Gcc обычная версия isqrt
добавлен флажок `-ffast-math` для компиляции математики через инструкции, иначе вызовы уходили во внешнюю `sqrtf()` со вполне понятными результатами.
```
       261 512 241      cycles
     1 501 618 130      instructions

       100 283 433      branches
             8 859      branch-misses
```

#### Clang обычная версия isqrt
добавлен флажок `-ffast-math` для компиляции математики через инструкции, иначе вызовы уходили во внешнюю `sqrtf()` со вполне понятными результатами.
```
       269 941 192      cycles
     1 301 780 676      instructions

       100 314 781      branches
             9 900      branch-misses
```

#### SSE версия isqrt
ручное топорное
```
    __m128 reg = _mm_set_ss(x);
    reg = _mm_rsqrt_ss(reg);
    return _mm_cvtss_f32(reg);
```

```
       202 577 821      cycles
     1 001 356 685      instructions

       100 238 787      branches
             7 729      branch-misses
```

#### квейковая Fast isqrt
использованы флажки `-mno-sse -mno-sse -mno-mmx -m32` для надежности, под x32 собрано чтобы протестировать использование FPU.
```
       601 396 220      cycles
     2 302 279 231      instructions

       100 394 734      branches
             8 495      branch-misses
```

#### обычная isqrt (Slow)
использованы флажки `-mno-sse -mno-sse -mno-mmx -m32` для надежности, под x32 собрано чтобы протестировать использование FPU.
```
     1 638 050 827      cycles
     1 004 441 542      instructions

       100 761 644      branches
            11 644      branch-misses
```

#### Rust
```
       842 574 350      cycles
       803 356 611      instructions

       100 587 197      branches
            15 810      branch-misses
```

